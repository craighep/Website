\documentclass[11pt,fleqn,twoside]{article}
\usepackage{makeidx}
\makeindex
\usepackage{palatino}
\usepackage{plain}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{mmpv2}
\usepackage{url}
\usepackage{cite}

\begin{document}

\name{Craig Heptinstall}
\userid{crh13}
\projecttitle{Create a WebGL based application that calculates and visualises the OLAN(One letter aerobatic notation) catalogue in the form of a 3D plane performing aerobatic manoeuvres}
\projecttitlememoir{A WebGL OLAN flight simulator} 
\reporttitle{Outline Project Specification}
\version{1.0}
\docstatus{Release}
\modulecode{CS39440}
\degreeschemecode{G601}
\degreeschemename{Software Engineering}
\supervisor{Neal Snooke}
\supervisorid{nns}
\wordcount{}
\mmp

\setcounter{tocdepth}{3}


%==============================================================================
\section{Project description}
%==============================================================================
My major project will be looking into the implementation of a WebGL flight simulator, though more importantly it will be based from manoeuvres outlined in the OLAN\cite{Olan}(One letter aerobatic notation)/Open Areo\cite{OpenAero} (Newer, updated and open source version of OLAN) format. The simulator should be web based, so run through any WebGL compatible browsers(Chrome, Opera, Firefox).\\
In more specific detail, the simulator should firstly allow for a range of different inputs(as string values) each of which should represent different manoeuvres according to OLAN. These will be space separated, and the previous move should link to the next in the most fluid means possible. Once the string of notations have been read in, then the system will use a list of predefined instructions from a JSON file which will allow each of the notations to be converted into a set of broken procedural movements(rotations, flips, angled movements).\\
Currently, there is a standard for drawing out these manoeuvres known as Aresti\cite{Aresti}. In addition to this, there is already current systems that allow input of OLAN, and ribbon diagrams are produced. These ribbon diagrams entail a 3d ribbon shape of the moves, showing where both tips of the wings would be on a plane. However, I am to improve on this, by making my application show the moves live, in a more aesthetic format. The ribbon will not be shown, but instead a plane will be shown flying the course defined, with smoke trails showing where it has already flown.  \\
To help the system achieve the different manoeuvres and physics required to perform them, I will be considering the use of a set of libraries such as Three.js\cite{ThreeJs} and glMatrix\cite{glMatrix}. Both these will provide some easier predefined methods allowing to perform some of the movements described previously. \\
Alongside the main functionality, additional features such as different camera angles, allowing the saving and loading of entire diagrams and adding pyshics will be considered. These though will be only be implimented once a good basis for the program is established. Overall, the main challenges that I will come across during this project will be issues in turning each OLAN figure into the appropriate translation in terms of the plane. With the project delivering a WebGL based product, it is easy to see the vast amount of the project will be created in Javascript.

%==============================================================================
\section{Proposed tasks}
%==============================================================================
In order to perform my project, I can break down the process into a selection for different tasks:
\begin{enumerate}
\item Read up on the OLAN and Aresti\cite{Aresti} notations- This will involve looking through the various possible manoeuvres that aerobatic planes can fly.
\item Investigate various WebGL technologies, especially Three.js, to see what forms of movements are possible using the library. For this I can spend plenty of time looking at other projects\cite{ThreejsDemo} around the web to see how certain transformations are done to objects on a canvas.
\item Look into how the site should look on completion- This will consider the size of the canvas on the site, and if mobile users should be able to view the product.
\item Look at the example OLAN to Aresti online program- Analyse each of the different ribbon diagrams, and see how different OLAN figures relate to one another. This key process will allow me to see what primary moves the entire collective notations can be made from. This could be compared to how every colour can be created from red, green, blue.
\item Create a set of functions relating to the findings to allow the program to create some form of ribbons, which can then be 'flown" by an object(a plane). This should utilise some form of stored list of moves and required actions.
\item Combine these into a clean, good looking WebGL product, to allow for inputs of OLAN, and controls such as camera angles.
\item Throughout the process, blog daily to log each task and time taken- This will allow an easier to create set of graphs, tables and references to project time taken on certain processes.
\end{enumerate}

%==============================================================================
\section{Project deliverables}
%==============================================================================
Following on from the previous section regarding the list of proposed tasks, I can relate these to a list of deliverables that the project shoudl produce. Although the simulator should primarily be an internet application acessable through a web browser, there will be a set of other items that will be created. I have chosen to create a blog, that will act like a form of self- documentation that should build up to create a work log. This will eventually be usefull in terms of relating it to a Gantt chart to see how well I am following the project plan. However, because I have decided on using an FDD (feature driven development) methodology to create my project the Gantt chart should allow for more flexibility. \\
Before I can impliment the simulator, I will also have to deliever a number of different planning documentation pieces. The first of these will be an analysis of botht the Aresti and OLAN langauges, which will allow me to understand how each manoeuver is broken down, and which primary elements can be combined to make other moves. After discovering these, it will be much easier to then create more broader methods to allow easier creation of more complicated simulations. \\
Alongside this, a table shoud be produced to further explain each move, and break down any where parameters should be needed. For instance, the size of a loop can be depicted by a radius size and height. Again, this will furtehr broaden the methods I will need to code thus producing much more flexible algorithms that can handle the maximum amount of different manoeuvers. The table should form a basis for my planning documentation. My project plan will then begin the FDD approach I am wanting to take, starting with a break down such as a list of features I would like the simulator to contain on completion. Once this is generated, I will then be able to break these into groups, each of which will be designed, implimented and tested.\\
Together with the blog, my implementation environment will be a GitHub based one, to allow for ease of working on the project in different places/ on different systems, and also to integrate it with any build servers I may want to use. In this case, I will be using Travis CI\cite{Travis} to build my tests (which will be written in QUnit\cite{QUnit} and run with Grunt\cite{Grunt})which will be useful for finding out any bugs or errors I may create in the process of implementing certain features.\\
To generalise on the final delverable and to come back to the first section of this paper, there should be a Web based application allowing the uer to input OLAN and hit a button allowing them to view (at different angles), control physics, speed and size of a set of defined manoevers with the functionality to save and load entire routines.

%==============================================================================
% Bibliography
%==============================================================================
\newpage
\addcontentsline{toc}{section}{Initial Annotated Bibliography}
\bibliographystyle{IEEEannot}
\renewcommand{\refname}{Annotated Bibliography}
\bibliography{mmp}

\end{document}
